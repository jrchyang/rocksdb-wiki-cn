## 简介

RocksDB 最初是 Facebook 推出的一款用于处理各种存储介质上的服务器工作负载的存储引擎，最初专注于快速存储（尤其是闪存）。它是一个 C++ 库，用于存储键和值，这些键和值是任意大小的字节流。它支持点查找和范围扫描，并提供不同类型的 ACID 保证。

在可定制性和自适应能力之间取得了平衡。RocksDB 具有高度灵活的配置设置，可以调整为在各种生产环境中运行，包括固态硬盘、硬盘、内存或远程存储。它支持各种压缩算法和良好的生产支持与调试工具。另一方面，它还努力限制旋钮的数量，提供足够好的开箱即用性能，并在适用的情况下使用一些自适应算法。

RocksDB 大量借鉴了开源 leveldb 项目的代码以及 Apache HBase 的理念。最初的代码来自开源 leveldb 1.5。它还借鉴了 Facebook 在 RocksDB 之前开发的代码和想法。

## 设想和目标

### 性能

RocksDB 的主要设计要点是它应该能够很好地处理快速存储和服务器工作负载。它应该支持高效的点查找以及范围扫描。它应该可配置以支持高随机读取工作负载、高更新工作负载或两者的组合。其架构应该支持轻松调整不同工作负载和硬件的权衡。

### 生产支持

RocksDB 在设计之初，就应该内置支持各种工具和实用程序，以帮助在生产环境中进行部署和调试。如果存储引擎还不能自动适应应用程序和硬件，我们将提供一些参数，以便用户调整性能。

### 兼容性

本软件的新版本应具有向后兼容性，因此现有应用程序在升级到 RocksDB 的新版本时无需进行更改。除非使用了新提供的功能，否则现有的应用程序也应该能够恢复到最近的旧版本。参见：[[不同版本之间的兼容性]]

## 高层架构

RocksDB 是一个键值存储接口的存储引擎库，其中键和值都是任意字节流。RocksDB 按排序顺序组织所有数据，常用操作包括 `Get(key)`、`NewIterator()`、`Put(key, val)`、`Delete(key)` 和 `SingleDelete(key)`。

RocksDB 的三个基本结构是 **memtable**、**sstfile** 和 **logfile**。[[内存表]] 是一种内存数据结构 - 新写入插入到 memtable 中，并可选择写入 [[预写日志]]。日志文件是一个按顺序写入的存储文件。当 memtable 填满时，它会刷新到存储中的 [[BlockBasedTable 格式| SST 文件]]，相应的日志文件也会被安全删除。sstfile 中的数据经过排序，便于查找键。

sstfile 的默认格式见：[[BlockBasedTable 格式]]

![高层架构](rocksdb-high_level_architecture.svg)

## 特性

### 列族

RocksDB 支持将数据库实例划分为多个列族。所有数据库在创建时都有一个名为 “默认 ”的列族，用于未指定列族的操作。

RocksDB 保证用户能在不同列族之间获得一致的视图，包括在启用 WAL 或原子刷新时的崩溃恢复后。它还通过 WriteBatch API 支持原子跨列族操作。

### 更新

Put API 向数据库插入一个键值。如果数据库中已经存在该键值，先前的值将被覆盖。Write API 允许在数据库中原子式插入、更新或删除多个键值。数据库保证，在一次 Write 调用中，所有键值都将被插入数据库，或者所有键值都不会被插入数据库。如果数据库中已经存在任何键值，以前的值将被覆盖。[[基础操作/范围删除|DeleteRange]] API 可用于删除范围中的所有键值。

### 获取、迭代器和快照

键和值被视为纯字节流。键或值的大小没有限制。`Get` API 允许应用程序从数据库中获取单个键值。通过 `MultiGet` API，应用程序可以从数据库中获取大量键值。通过 `MultiGet` 调用返回的所有键值都相互一致。

数据库中的所有数据在逻辑上都是顺序排列的。应用程序可以指定一种键比较方法，以指定键的总排序。迭代器 API 允许应用程序对数据库进行范围扫描。迭代器可以搜索到一个指定的键，然后应用程序可以从该点开始一次扫描一个键。迭代器 API 还可用于对数据库中的键进行反向迭代。创建迭代器时，会创建数据库的一致时间点视图。因此，通过迭代器返回的所有键值都来自数据库的一致视图。

[[快照]] API 允许应用程序创建数据库的时间点视图。获取和迭代器 API 可用于从指定的快照中读取数据。从某种意义上说，快照和迭代器都提供了数据库的时间点视图，但它们的实现方式不同。短期/前台扫描最好通过迭代器完成，而长期/后台扫描最好通过快照完成。迭代器会保留与数据库时间点视图相对应的所有底层文件的引用计数，这些文件在迭代器被释放前不会被删除。另一方面，快照不会阻止文件删除；相反，压实过程会了解快照的存在，并承诺永远不会删除任何现有快照中可见的键。

快照不会在数据库重启时持续存在：重新加载 RocksDB 库（通过服务器重启）会释放所有已存在的快照。

### 事务

RocksDB 支持多操作事务，它支持乐观模式和悲观模式，详见：[[事务]]

### 前缀迭代

大多数 LSM 树引擎都无法支持高效的范围扫描 API，因为它需要查看多个数据文件。但是，大多数应用程序不会对数据库中的键范围进行纯随机扫描；相反，应用程序通常会在键前缀范围内进行扫描。RocksDB正是利用了这一点。应用程序可以配置一个 Options.prefix_extractor（前缀提取器）来启用基于键前缀的过滤。当设置 Options.prefix_extractor 时，前缀的哈希值也会被添加到 Bloom 中。指定了键前缀（在 ReadOptions 中）的迭代器将使用 [[Bloom 过滤器]] 来避免查找不包含指定键前缀的数据文件。详见：[[前缀查找]]

### 持久性

RocksDB 有一个 [[预写日志]]。所有写入操作（写入、删除和合并）都存储在一个名为内存表（memtable）的内存缓冲区中，并有选择地插入到 WAL 中。重启时，它会重新处理日志中记录的所有事务。

可以将 WAL 配置为存储在与 SST 文件所在目录不同的目录中。这对于希望将所有数据文件存储在非持久快速存储中的情况是必要的。同时，将所有事务日志放在速度较慢但持久的存储中，可以确保数据不会丢失。

每个 `Put` 都有一个通过 `WriteOptions` 设置的标志，用于指定是否将该 `Put` 插入事务日志。`WriteOptions` 还可以指定是否在声明提交 `Put` 之前向事务日志发出 `fsync` 调用。

在内部，RocksDB 使用批量提交机制将事务批量提交到日志中，这样它就有可能通过一次 fsync 调用提交多个事务。

### 数据校验

RocksDB 使用校验和来检测存储中的损坏。这些校验和是针对每个 SST 文件块（大小通常在 `4K` 到 `128K` 之间）的。文件块一旦被写入存储空间，就永远不会被修改。RocksDB 还会维护一个全文件校验和（详见：[[完整文件校验和与校验和切换]]），以及 [每个键值的校验和](https://rocksdb.org/blog/2022/07/18/per-key-value-checksum.html)。

RocksDB 可以动态检测并使用 CPU 校验和卸载支持。

### 多线程压实

在持续写入的情况下，需要进行压实以提高空间效率、读取（查询）效率和及时删除数据。压实会删除已删除或覆盖的键值绑定，并重新组织数据以提高查询效率。如果进行了配置，压缩可以在多个线程中进行。

整个数据库存储在一组 sstfiles 中。当 memtable 时，其内容会被写入 LSM 树的第 0 层（L0）文件。当 memtable 被刷新到 L0 级文件时，RocksDB 会删除 memtable 中重复和被覆盖的键。在压实过程中，一些文件会被定期读入并合并成更大的文件，通常会进入下一个 LSM 层（比如 L1，直到 Lmax）。

LSM 数据库的整体写入吞吐量直接取决于压缩的速度，尤其是当数据存储在固态硬盘或内存等快速存储器中时。RocksDB 可以配置为从多个线程同时发出压实请求。据观察，与单线程压实相比，当数据库位于固态硬盘上时，多线程压缩的持续写入率可提高 10 倍之多。

### 压实类型

分级压实和通用压实都将数据存储在数据库中固定数量的逻辑级别中。较新的数据存储在第 0 层 (L0)，较旧的数据存储在较高编号的层中，直到 Lmax。L0 中的文件可能有重叠的键，但其他级别中的文件通常在每个级别中形成一个排序运行。

分级压缩（默认）通常是通过最小化每个压实步骤中涉及的文件来优化磁盘占用空间与逻辑数据库大小的关系（空间放大）：将 Ln 中的一个文件与其 Ln+1 中的所有重叠文件合并，并用 Ln+1 中的新文件替换它们。

通用压实通常通过一次性合并潜在的多个文件和级别（需要更多临时空间）来优化写入磁盘的总字节数与逻辑数据库大小（写放大）。与分级压缩相比，通用压实的写入放大率通常较低，但空间和读取放大率较高。

先进先出压实会在文件过时时丢弃最老的文件，可用于类似缓存的数据。在 FIFO 压实中，所有文件都处于 0 级。当数据总大小超过配置大小（`CompactionOptionsFIFO::max_table_files_size`）时，我们会删除最旧的表文件。

我们还允许开发者开发和尝试自定义压实策略。为此，RocksDB 提供了适当的钩子来关闭内置的压实算法，并提供了其他应用程序接口来允许应用程序运行自己的压实算法。如果设置了 `Options.disable_auto_compaction`，就会关闭本地压实算法。`GetLiveFilesMetaData API` 允许外部组件查看数据库中的每个数据文件，并决定合并和压实哪些数据文件。调用 `CompactFiles` 可以压实您想要的文件。`DeleteFile API` 允许应用程序删除被视为过时的数据文件。

### 元数据存储

清单日志文件用于记录所有数据库状态变化。压实过程会从数据库中添加新文件和删除现有文件，并将这些操作记录在 [[MANIFEST]] 中，使其持久化。

### 避免 Stalls

后台压实线程还用于将 memtable 内容刷新到存储文件中。如果所有的后台压实线程都在忙于进行长时间的压实，那么突然的写入就会迅速填满memtable，从而导致新的写入停滞。要避免这种情况，可以通过配置 RocksDB，明确保留一小部分线程，专门用于将内存表刷新到存储空间。

### 压实过滤器

有些应用程序可能希望在压实时处理键。例如，固有支持生存时间（TTL）的数据库可以删除过期的键。这可以通过应用程序定义的 [[压实过滤器]]（Compaction-Filter）来实现。如果应用程序想要持续删除超过特定时间的数据，就可以使用压实过滤器来删除过期的记录。RocksDB 压实过滤器可以控制应用程序修改键值，或者在压实过程中完全删除键值。例如，应用程序可以在压实过程中持续运行数据清除器。

### 只读模式

数据库可以在只读模式下打开，在这种模式下，数据库保证应用程序不得修改数据库中的任何内容。这将大大提高读取性能，因为经常遍历的代码路径可以完全避免锁。

### 调试日志

默认情况下，RocksDB 会将详细日志写入一个名为 LOG* 的文件。这些日志主要用于调试和分析运行中的系统。用户可以选择不同的日志级别（参见 `DBOptions.info_log_level`）。日志文件可配置为按指定周期滚动。日志接口是可插拔的,用户可以插入不同的日志记录器。详见：[[Logger]]

### 数据压缩

RocksDB 支持 lz4、zstd、snappy、zlib 和 lz4_hc 压缩，以及 Windows 下的 xpress。RocksDB 可以为最底层的数据配置不同的压缩算法，因为 90% 的数据都存放在最底层。典型的安装可能会为最底层配置 ZSTD（或 Zlib，如果不可用），为其他层配置 LZ4（或 Snappy，如果不可用）。详见：[[压缩]]

### 完整备份和复制

RocksDB 提供了一个备份 API，即 `BackupEngine`。详见：[[如何备份]]

RocksDB 本身并不是一个复制系统，但它提供了一些辅助函数，让用户可以在 RocksDB 的基础上实现自己的复制系统。详见：[[复制助手]]

### 在同一进程中支持多个嵌入式数据库

RocksDB 的一个常见用例是，应用程序将其数据集固有地划分为逻辑分区或碎片。这种技术有利于应用程序的负载平衡和故障的快速恢复。这意味着，单个服务器进程应能同时运行多个 RocksDB 数据库。这可以通过一个名为 `Env` 的环境对象来实现。其中，线程池与环境对象相关联。如果应用程序希望在多个数据库实例之间共享一个线程池（用于后台压缩），那么就应该使用同一个环境对象来打开这些数据库。

同样，多个数据库实例可以共享同一个块缓存或速率限制器。

### 块缓存 -- 压缩和未压缩数据

RocksDB 使用 [[块缓存|LRU 块缓存]] 来提供读取服务。数据块缓存被划分为两个独立的缓存：第一个缓存是未压缩的数据块，第二个缓存是 RAM 中的压缩数据块。如果配置了压缩块缓存，用户可能希望启用 [[Direct IO]]，以防止在操作系统页面缓存中对相同数据进行冗余缓存。

### 表缓存

表缓存是一种缓存打开的文件描述符的结构。这些文件描述符是用于 sstfiles 的。应用程序可以指定表缓存的最大大小，或者配置 RocksDB 始终保持所有文件打开，以获得更好的性能。

### IO 控制

RocksDB 允许用户以不同的方式配置 SST 文件的 I/O。用户可以启用直接 I/O，这样 RocksDB 就能完全控制 I/O 和缓存。另一种方法是利用一些选项来让用户提示 I/O 的执行方式。用户可以建议 RocksDB 在要读取的文件中调用 `fadvise`，在要添加的文件中调用定期范围同步，启用直接 I/O 等。详见：[[IO]]

### 可堆叠 DB

RocksDB 有一个内置的封装机制，可以在代码数据库内核之上添加一层功能。这些功能由 `StackableDB API` 封装。例如，“时间-生存”（time-to-live）功能就是由 `StackableDB` 实现的，而不是 RocksDB 核心 API 的一部分。这种方法可以保持代码的模块化和整洁。

### 内存表

#### 可插拔内存表

RocksDB 的默认 memtable 实现是一个 skiplist。skiplist 是一个排序集，当工作负载将写入和范围扫描交错在一起时，这是一个必要的结构。不过，有些应用程序并不交错写入和扫描，有些应用程序根本不进行范围扫描。对于这些应用，排序集可能无法提供最佳性能。因此，RocksDB 的 memtable 是可插拔的。我们还提供了一些替代实现。该库包含三个 memtable：skiplist memtable、vector memtable 和 prefix-hash memtable。vector memtable 适用于向数据库批量加载数据。每次写入都会在 vector 的末尾插入一个新元素；当需要将内存表刷新到存储空间时，vector 中的元素会被排序并写入 L0 中的文件。使用前缀哈希 memtable，可以高效地处理 get、put 和 key-prefix 内的扫描。虽然 memtable 的可插拔性没有作为公共应用程序接口提供，但应用程序可以在私有 clone 中提供自己的 memtable 实现。

#### 内存表流水线

RocksDB 支持为数据库配置任意数量的内存表。当一个内存表满了之后，它就会变成一个不可变的内存表，后台线程会开始将其内容刷新到存储空间中。与此同时，新写入的内容会继续累积到新分配的 memtable 中。如果新分配的 memtable 被填满到极限，它也会被转换为不可变的 memtable，并被插入到刷新流水线中。后台线程会继续将所有流水线中的不可变内存表刷新到存储中。这种流水线操作提高了 RocksDB 的写入吞吐量，尤其是在慢速存储设备上运行时。

#### 内存表刷新时的垃圾回收

当内存表被刷新到存储空间时，会执行一个内联压缩过程。清除垃圾的方式与压实相同。同一键的重复更新会从输出流中删除。同样，如果先前的输入被后来的删除所隐藏，那么该输入将不会被写入输出文件。对于某些工作负载，这一功能可大大减少存储数据的大小和写入放大。

### 合并操作

RocksDB 原生支持三种记录类型，即 `Put` 记录、`Delete` 记录和 `Merge` 记录。当压实进程遇到 Merge 记录时，它会调用一个应用程序指定的方法，即合并操作器（Merge Operator）。合并可将多个 `Put` 和 `Merge` 记录合并为一条记录。这项强大的功能允许通常进行读取-修改-写入操作的应用程序完全避免读取操作。它允许应用程序将操作意图记录为合并记录，然后 RocksDB 压实过程会将该意图懒散地应用到原始值中。该功能的详细描述请参见：[[合并操作器]]

### DB ID

创建数据库时创建的全局唯一 ID，默认存储在 DB 文件夹中的 IDENTITY 文件中。也可选择只存储在 MANIFEST 文件中。建议存储在 MANIFEST 文件中。

## 工具

有许多有趣的工具可用于支持生产中的数据库。sst_dump 工具可以转储 sst 文件中的所有键值以及其他信息。ldb 工具可以放入、获取、扫描数据库的内容。ldb 还可以转储 MANIFEST 的内容，还可以用来更改数据库的配置级别数。详见：[[管理和数据访问工具]]

## 测试

有许多单元测试用于测试数据库的特定功能。`make check` 命令可以运行所有的单元测试。这些单元测试会触发 RocksDB 的特定功能，而不是用来测试大规模数据的正确性。`db_stress` 测试用于验证大规模数据的正确性。参见：[[压力测试]]。你也可以在 [这个目录](https://github.com/facebook/rocksdb/tree/main/fuzz) 下添加模糊器，利用那里的 [模糊](https://en.wikipedia.org/wiki/Fuzzing) 基础架构，模糊器会在谷歌的 [OSS-Fuzz](https://github.com/google/oss-fuzz/tree/master/projects/rocksdb) 上持续运行，错误会被报告给 RocksDB 开发者。

## 性能

RocksDB 的性能是通过一个名为 `db_bench` 的工具来进行基准测试的。`db_bench` 是 RocksDB 源代码的一部分。[这里](https://github.com/facebook/rocksdb/wiki/Performance-Benchmarks) 描述了一些使用闪存存储的典型工作负载的性能结果。你也可以在 [这里](https://github.com/facebook/rocksdb/wiki/RocksDB-In-Memory-Workload-Performance-Benchmarks) 找到 RocksDB 在内存中工作负载的性能结果。
